[
  {
    "objectID": "sessions/api.html#comprendre-le-principe-avec-un-exemple-interactif",
    "href": "sessions/api.html#comprendre-le-principe-avec-un-exemple-interactif",
    "title": "Atelier pour dÃ©couvrir la rÃ©cupÃ©ration de donnÃ©es via des API",
    "section": "2.1 Comprendre le principe avec un exemple interactif",
    "text": "2.1 Comprendre le principe avec un exemple interactif\nLe premier mode (accÃ¨s par un navigateur) est principalement utilisÃ© lorsquâ€™une interface web permet Ã  un utilisateur de faire des choix afin de lui renvoyer des rÃ©sultats correspondant Ã  ceux-ci. Prenons Ã  nouveau lâ€™exemple de lâ€™API de gÃ©olocalisation que nous utiliserons dans ce chapitre. Imaginons une interface web permettant Ã  lâ€™utilisateur deux choix : un code postal et une adresse. Cela sera injectÃ© dans la requÃªte et le serveur rÃ©pondra avec la gÃ©olocalisation adaptÃ©e.\n\n\n\nviewof codePostal = Inputs.text({value: \"92120\", placeholder: \"92120\", label: md`**Code Postal**`})\n\n\n\n\n\n\n\n\n\n\nviewof adresse = Inputs.text({value: defaultAdresse, placeholder: defaultAdresse, label: md`**Adresse**`})\n\n\n\n\n\n\n\n\n\nmd`\n${\nawait mj`$$\\underbrace{\\text{${apiroot}}}_{\\text{API root}}/\\underbrace{\\text{search}}_{\\text{API endpoint}}/?\\underbrace{\\text{${param1}}}_{\\text{main parameter}}\\&\\underbrace{\\text{${param2}}}_{\\text{additional parameter}}$$`\n}\n`\n\n\n\n\n\n\n\nmap = {\n  const container = html`&lt;div style=\"height:300px;\"&gt;`;\n  yield container;\n  const map = L.map(container).setView([latitude, longitude], 13);\n  L.tileLayer(\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\", {\n    attribution: \"&copy; &lt;a href=https://www.openstreetmap.org/copyright&gt;OpenStreetMap&lt;/a&gt; contributors\"\n  }).addTo(map);\n  var marker = L.marker([latitude, longitude]).addTo(map);\n  marker.bindPopup(\"&lt;b&gt;TrouvÃ© !&lt;/b&gt;\").openPopup();\n  return map\n}\n\n\n\n\n\n\nğŸ” Allons voir ce que cela donne dans lâ€™onglet RÃ©seau des outils de dÃ©veloppement de notre navigateur (dans firefox, raccourci  CTRL+MAJ+K).\n\nhtml`\n Pour preuve que cette requÃªte est bien fonctionnelle, on peut l'ouvrir dans un navigateur : &lt;a href=\"${url}\" target=\"_blank\" title=\"Test de url dans un navigateur\"&gt;\n &lt;i class=\"fa-solid fa-magnifying-glass\"&gt;&lt;/i&gt;&lt;/i&gt;\n`\n\n\n\n\n\n\nCe qui nous donne un output au format JSON, le format de sortie dâ€™API le plus commun.\nSi on veut un beau rendu, comme la carte ci-dessus, il faudra que le navigateur retravaille cet output, ce qui se fait normalement avec Javascript, le langage de programmation embarquÃ© par les navigateurs."
  },
  {
    "objectID": "sessions/api.html#comment-faire-avec-python",
    "href": "sessions/api.html#comment-faire-avec-python",
    "title": "Atelier pour dÃ©couvrir la rÃ©cupÃ©ration de donnÃ©es via des API",
    "section": "2.2 Comment faire avec Python  ?",
    "text": "2.2 Comment faire avec Python  ?\nLe principe est le mÃªme sauf que nous perdons lâ€™aspect interactif. Il sâ€™agira donc, avec Python, de construire lâ€™URL voulue et dâ€™aller chercher via une requÃªte HTTP le rÃ©sultat.\nPython communique avec internet : via le package requests. Ce package suit le protocole HTTP oÃ¹ on retrouve principalement deux types de requÃªtes : GET et POST :\n\nLa requÃªte GET est utilisÃ©e pour rÃ©cupÃ©rer des donnÃ©es depuis un serveur web. Câ€™est la mÃ©thode la plus simple et courante pour accÃ©der aux ressources dâ€™une page web. Nous allons commencer par dÃ©crire celle-ci.\nLa requÃªte POST est utilisÃ©e pour envoyer des donnÃ©es au serveur, souvent dans le but de crÃ©er ou de mettre Ã  jour une ressource. Sur les pages web, elle sert souvent Ã  la soumission de formulaires qui nÃ©cessitent de mettre Ã  jour des informations sur une base (mot de passe, informations clients, etc.). Nous verrons son utilitÃ© plus tard, lorsque nous commencerons Ã  rentrer dans les requÃªtes authentifiÃ©es oÃ¹ il faudra soumettre des informations supplÃ©mentaires Ã  notre requÃªte.\n\nFaisons un premier test avec Python en faisant comme si nous connaissions bien cette API.\n\nimport requests\nadresse = \"88 avenue verdier\"\nurl_ban_example = f\"https://api-adresse.data.gouv.fr/search/?q={adresse.replace(\" \", \"+\")}&postcode=92120\"\nrequests.get(url_ban_example)\n\nQuâ€™est-ce quâ€™on obtient ? Un code HTTP. Le code 200 correspond aux requÃªtes rÃ©ussies, câ€™est-Ã -dire pour lesquelles le serveur est en mesure de rÃ©pondre. Si ce nâ€™est pas le cas, pour une raison x ou y, vous aurez un code diffÃ©rent.\n\n\n\n\n\n\nLes codes HTTP\n\n\n\n\n\nLes codes de statut HTTP sont des rÃ©ponses standard envoyÃ©es par les serveurs web pour indiquer le rÃ©sultat dâ€™une requÃªte effectuÃ©e par un client (comme un navigateur ou un script Python). Ils sont classÃ©s en diffÃ©rentes catÃ©gories selon le premier chiffre du code :\n\n1xx : Informations\n2xx : SuccÃ¨s\n3xx : Redirections\n4xx : Erreurs cÃ´tÃ© client\n5xx : Erreurs cÃ´tÃ© serveur\n\nCeux Ã  retenir sont : 200 (succÃ¨s), 400 (requÃªte mal structurÃ©e), 401 (authentification non rÃ©ussie), 403 (accÃ¨s interdit), 404 (ressource demandÃ©e nâ€™existe pas), 503 (le serveur nâ€™est pas en capacitÃ© de rÃ©pondre)\n\n\n\nPour rÃ©cupÃ©rer le contenu renvoyÃ© par requests, il existe plusieurs mÃ©thodes. Quand on un JSON bien formattÃ©, le plus simple est dâ€™utiliser la mÃ©thode json qui transforme cela en dictionnaire :\n\nreq = requests.get(url_ban_example)\nlocalisation_insee = req.json()\nlocalisation_insee\n\nEn lâ€™occurrence, on voit que les donnÃ©es sont dans un JSON imbriquÃ©. Il faut donc dÃ©velopper un peu de code pour rÃ©cupÃ©rer les informations voulues dans celui-ci:\n\nlocalisation_insee.get('features')[0].get('properties')\n\nCâ€™est lÃ  lâ€™inconvÃ©nient principal de lâ€™usage des API : le travail ex post sur les donnÃ©es renvoyÃ©es est parfois important. Le code nÃ©cessaire est propre Ã  chaque API puisque lâ€™architecture du JSON dÃ©pend de chaque API."
  },
  {
    "objectID": "sessions/api.html#comment-connaÃ®tre-les-inputs-et-outputs-des-api",
    "href": "sessions/api.html#comment-connaÃ®tre-les-inputs-et-outputs-des-api",
    "title": "Atelier pour dÃ©couvrir la rÃ©cupÃ©ration de donnÃ©es via des API",
    "section": "2.3 Comment connaÃ®tre les inputs et outputs des API ?",
    "text": "2.3 Comment connaÃ®tre les inputs et outputs des API ?\nIci on a pris lâ€™API BAN comme un outil magique dont on connaissait les principaux inputs (le endpoint, les paramÃ¨tres et leur formattageâ€¦). Mais comment faire, en pratique, pour en arriver lÃ  ? Tout simplement en lisant la documentation lorsquâ€™elle existe et en testant celle-ci via des exemples.\nLes bonnes API proposent un outil interactif qui sâ€™appelle le swagger. Câ€™est un site web interactif oÃ¹ sont dÃ©crites les principales fonctionnalitÃ©s de lâ€™API et oÃ¹ lâ€™utilisateur peut tester des exemples interactivement. Ces documentations sont souvent crÃ©Ã©es automatiquement lors de la construction dâ€™une API et mises Ã  disposition par le biais dâ€™un point dâ€™entrÃ©e /docs. Elles permettent souvent dâ€™Ã©diter certains paramÃ¨tres dans le navigateur, voir le JSON obtenu (ou lâ€™erreur gÃ©nÃ©rÃ©e) et rÃ©cupÃ©rer la requÃªte formattÃ©e qui permet dâ€™obtenir celui-ci. Ces consoles interactives dans le navigateur permettent de rÃ©pliquer le tÃ¢tonnement quâ€™on peut faire par ailleurs dans des outils spÃ©cialisÃ©s comme postman.\nConcernant lâ€™API BAN, la documentation se trouve sur https://adresse.data.gouv.fr/api-doc/adresse. Elle nâ€™est pas interactive, malheureusement. Mais elle prÃ©sente de nombreux exemples qui peuvent Ãªtre testÃ©s directement depuis le navigateur. Il suffit dâ€™utiliser les URL proposÃ©es comme exemple. Ceux-ci sont prÃ©sentÃ©s par le biais de curl (un Ã©quivalent de requests en ligne de commande Linux ):\ncurl \"https://api-adresse.data.gouv.fr/search/?q=8+bd+du+port&limit=15\"\nIl suffit de copier lâ€™URL en question (https://api-adresse.data.gouv.fr/search/?q=8+bd+du+port&limit=15), dâ€™ouvrir un nouvel onglet et vÃ©rifier que cela produit bien un rÃ©sultat. Puis de changer un paramÃ¨tre et vÃ©rifier Ã  nouveau, jusquâ€™Ã  trouver la structure qui convient. Et aprÃ¨s, on peut passer Ã  Python comme le propose lâ€™exercice suivant."
  },
  {
    "objectID": "sessions/api.html#application",
    "href": "sessions/api.html#application",
    "title": "Atelier pour dÃ©couvrir la rÃ©cupÃ©ration de donnÃ©es via des API",
    "section": "2.4 Application",
    "text": "2.4 Application\nPour la prochaine application, nous allons utiliser lâ€™adresse suivante :\n\nadresse = \"88 Avenue Verdier\"\n\n\n\n\n\n\n\nExercice 1 : Structurer un appel Ã  une API depuis Python\n\n\n\n\nTester sans aucun autre paramÃ¨tre, le retour de notre API. Transformer en DataFrame le rÃ©sultat.\nSe restreindre Ã  Montrouge avec le paramÃ¨tre ad hoc et la recherche du code insee ou code postal adÃ©quat sur Google.\n(Optionnel) : ReprÃ©senter lâ€™adresse trouvÃ©e sur une carte.\n\n\n\n\n\nCorrection question 1\nimport requests\nimport pandas as pd\n\nban_root = \"https://api-adresse.data.gouv.fr\"\nban_search_endpoint = \"search\"\napi_ban_q1 = f\"{ban_root}/{ban_search_endpoint}?q={adresse.replace(\" \", \"+\")}\"\noutput_api_ban = requests.get(api_ban_q1).json().get('features')\n\ndf_avenue_verdier = pd.DataFrame(\n    [out['properties'] for out in output_api_ban]\n)\n\n\nLes deux premiÃ¨res lignes du dataframe obtenu Ã  la question 1 devraient Ãªtre\nA la question 2, la requÃªte ne renvoie cette fois quâ€™une seule observation, quâ€™on pourrait retravailler avec GeoPandas pour vÃ©rifier quâ€™on a bien placÃ© ce point sur une carte\n\n\nCorrection question 2\nimport pandas as pd\nimport geopandas as gpd\n\napi_ban_q2 = f\"{ban_root}/{ban_search_endpoint}?q={adresse.replace(\" \", \"+\")}&postcode=92120\"\noutput_q2 = requests.get(api_ban_q2).json()\n\noutput_q2 = pd.DataFrame(\n    [output_q2.get(\"features\")[0]['properties']]\n)\noutput_q2 = gpd.GeoDataFrame(\n    output_q2,\n    geometry=gpd.points_from_xy(output_q2.x, output_q2.y), crs=\"EPSG:2154\"\n).to_crs(4326)\noutput_q2\n\n\nEnfin, Ã  la question 3, on obtient cette carte (plus ou moins la mÃªme que prÃ©cÃ©demment) :\n\n\nCorrection question 3\nimport folium\n\n# Extraire la longitude et la latitude\nlongitude = output_q2.geometry.x.iloc[0]\nlatitude = output_q2.geometry.y.iloc[0]\n\n# CrÃ©er une carte Folium centrÃ©e sur le point\nm = folium.Map(location=[latitude, longitude], zoom_start=16)\n\n# DÃ©finir le contenu de la popup\npopup_content = f\"\"\"\n&lt;b&gt;{output_q2['name'].iloc[0]}&lt;/b&gt; has been found!\n\"\"\"\n\n# Ajouter le marqueur\nfolium.Marker(\n    location=[latitude, longitude],\n    popup=folium.Popup(popup_content, max_width=300),\n    icon=folium.Icon(color='blue', icon='info-sign')\n).add_to(m)\n\n# Afficher la carte dans le notebook (si utilisÃ© dans un Jupyter Notebook)\nm\n\n\n\n\n\n\n\n\nQuelques exemples dâ€™API Ã  connaÃ®tre\n\n\n\n\n\nLes principaux fournisseurs de donnÃ©es officielles proposent des API. Câ€™est le cas notamment de lâ€™Insee, dâ€™Eurostat, de la BCE, de la FED, de la Banque Mondialeâ€¦\nNÃ©anmoins, la production de donnÃ©es par les institutions publiques est loin dâ€™Ãªtre restreinte aux producteurs de statistiques publiques. Le portail API gouv est le point de rÃ©fÃ©rencement principal pour les API produites par lâ€™administration centrale franÃ§aise ou des administrations territoriales. De nombreuses villes publient Ã©galement des donnÃ©es sur leurs infrastructures par le biais dâ€™API, par exemple la ville de Paris.\nLes producteurs de donnÃ©es privÃ©es proposent Ã©galement des API. Par exemple, la SNCF ou la RATP proposent des API pour certains usages. Les grands acteurs du numÃ©rique, par exemple Spotify  proposent gÃ©nÃ©ralement des API pour intÃ©grer certains de leurs services Ã  des applications externes.\nCependant, il faut Ãªtre conscient des limites de certaines API. En premier lieu, les donnÃ©es partagÃ©es ne sont pas forcÃ©ment trÃ¨s riches pour ne pas compromettre la confidentialitÃ© des informations partagÃ©es par les utilisateurs du service ou la part de marchÃ© du producteur qui nâ€™a pas intÃ©rÃªt Ã  vous partager ses donnÃ©es Ã  forte valeur. Il faut Ã©galement Ãªtre conscient du fait quâ€™une API peut disparaÃ®tre ou changer de structure du jour au lendemain. Les codes de restructuration de donnÃ©es Ã©tant assez adhÃ©rents Ã  une structure dâ€™API, on peut se retrouver Ã  devoir changer un volume consÃ©quent de code si une API critique change substantiellement."
  },
  {
    "objectID": "sessions/api.html#source-principale",
    "href": "sessions/api.html#source-principale",
    "title": "Atelier pour dÃ©couvrir la rÃ©cupÃ©ration de donnÃ©es via des API",
    "section": "3.1 Source principale",
    "text": "3.1 Source principale\nNous allons utiliser comme base principale pour ce tutoriel la base permanente des Ã©quipements, un rÃ©pertoire dâ€™Ã©quipements publics accueillant du public.\nOn va commencer par rÃ©cupÃ©rer les donnÃ©es qui nous intÃ©ressent. On ne rÃ©cupÃ¨re pas toutes les variables du fichier mais seulement celles quâ€™ils nous intÃ©ressent : quelques variables sur lâ€™Ã©quipement, son adresse et sa commune dâ€™appartenance.\nNous allons nous restreindre aux Ã©tablissements dâ€™enseignement primaire, secondaire et supÃ©rieur du dÃ©partement de la Haute-Garonne (le dÃ©partement 31). Ces Ã©tablissements sont identifiÃ©s par un code particulier, entre C1 et C5.\n\nimport duckdb\n\nquery = \"\"\"\nFROM read_parquet('https://minio.lab.sspcloud.fr/lgaliana/diffusion/BPE23.parquet')\nSELECT NOMRS, NUMVOIE, INDREP, TYPVOIE, LIBVOIE,\n       CADR, CODPOS, DEPCOM, DEP, TYPEQU,\n       concat_ws(' ', NUMVOIE, INDREP, TYPVOIE, LIBVOIE) AS adresse, SIRET\nWHERE DEP = '31'\n      AND starts_with(TYPEQU, 'C')\n      AND NOT (starts_with(TYPEQU, 'C6') OR starts_with(TYPEQU, 'C7'))\n\"\"\"\n\nbpe = duckdb.sql(query)\nbpe = bpe.to_df()\n\nbpe.head(2)"
  },
  {
    "objectID": "sessions/api.html#rÃ©cupÃ©rer-des-donnÃ©es-Ã -faÃ§on-grÃ¢ce-aux-api",
    "href": "sessions/api.html#rÃ©cupÃ©rer-des-donnÃ©es-Ã -faÃ§on-grÃ¢ce-aux-api",
    "title": "Atelier pour dÃ©couvrir la rÃ©cupÃ©ration de donnÃ©es via des API",
    "section": "3.2 RÃ©cupÃ©rer des donnÃ©es Ã  faÃ§on grÃ¢ce aux API",
    "text": "3.2 RÃ©cupÃ©rer des donnÃ©es Ã  faÃ§on grÃ¢ce aux API\nNous avons vu prÃ©cÃ©demment le principe gÃ©nÃ©ral dâ€™une requÃªte dâ€™API. Pour illustrer, de maniÃ¨re plus massive, la rÃ©cupÃ©ration de donnÃ©es par le biais dâ€™une API, essayons de rÃ©cupÃ©rer des donnÃ©es complÃ©mentaires Ã  notre source principale. Nous allons utiliser lâ€™annuaire de lâ€™Ã©ducation qui fournit de nombreuses informations sur les Ã©tablissements scolaires. Nous utiliserons le SIRET pour croiser les deux sources de donnÃ©es.\nLâ€™exercice suivant viendra illustrer lâ€™intÃ©rÃªt dâ€™utiliser une API pour avoir des donnÃ©es Ã  faÃ§on et la simplicitÃ© Ã  rÃ©cupÃ©rer celles-ci via Python. NÃ©anmoins, cet exercice illustrera Ã©galement une des limites de certaines API, Ã  savoir la volumÃ©trie des donnÃ©es Ã  rÃ©cupÃ©rer.\n\n\n\n\n\n\nExercice 2\n\n\n\n\nVisiter le swagger de lâ€™API de lâ€™Annuaire de lâ€™Education nationale sur api.gouv.fr/documentation, et plus particuliÃ¨rement sa â€œdocumentation externeâ€ qui permet de gÃ©nÃ©rer les urls souhaitÃ©es en prototypant interactivement les requÃªtes. Tester une premiÃ¨re rÃ©cupÃ©ration de donnÃ©es en utilisant le endpoint records sans aucun paramÃ¨tre.\nPuisquâ€™on nâ€™a conservÃ© que les donnÃ©es de la Haute Garonne dans notre base principale, on dÃ©sire ne rÃ©cupÃ©rer que les Ã©tablissements de ce dÃ©partement par le biais de notre API. Faire une requÃªte avec le paramÃ¨tre ad hoc, sans en ajouter dâ€™autres.\nAugmenter la limite du nombre de paramÃ¨tres, voyez-vous le problÃ¨me ?\nOn va tenter de rÃ©cupÃ©rer ces donnÃ©es par le biais de lâ€™API tabular de data.gouv. Sa documentation est ici et lâ€™identifiant de la ressource est b22f04bf-64a8-495d-b8bb-d84dbc4c7983 (source). Avec lâ€™aide de la documentation, essayer de rÃ©cupÃ©rer des donnÃ©es par le biais de cette API en utilisant le paramÃ¨tre Code_departement__exact=031 pour ne garder que le dÃ©partement dâ€™intÃ©rÃªt.\nVoyez-vous le problÃ¨me et comment nous pourrions automatiser la rÃ©cupÃ©ration de donnÃ©es ?\n\n\n\n\n\nRÃ©ponse question 1\nimport requests\n\nurl_annuaire_education = \"https://data.education.gouv.fr/api/explore/v2.1/catalog/datasets/fr-en-annuaire-education/records\"\n\nschool_q1_exo2 = pd.DataFrame(\n  requests\n  .get(url_annuaire_education)\n  .json()\n  .get(\"results\")\n)\n\nschool_q1_exo2.head(2)\n\n\nNÃ©anmoins, on a deux problÃ¨mes : le nombre de lignes et le dÃ©partement dâ€™intÃ©rÃªt. Essayons dÃ©jÃ  avec la question 2 de changer ce dernier.\n\n\nRÃ©ponse question 2\nurl_31_limite10 = \"https://data.education.gouv.fr/api/explore/v2.1/catalog/datasets/fr-en-annuaire-education/records?where=code_departement%20like%20%22031%22\"\n\nschool_q2_exo2 = pd.DataFrame(\n  requests\n  .get(url_31_limite10)\n  .json()\n  .get(\"results\")\n)\nschool_q2_exo2.head()\n\n\nCâ€™est mieux, mais nous avons toujours seulement 10 observations. Si on essaie dâ€™ajuster le nombre de lignes (question 3), on obtient le retour suivant de lâ€™API :\n\n\nQuestion 3\nurl_31_limite200 = \"https://data.education.gouv.fr/api/explore/v2.1/catalog/datasets/fr-en-annuaire-education/records?where=code_departement%20like%20%22031%22&limit=200\"\n\nrequests.get(url_31_limite200).json()\n\n\nEssayons avec des donnÃ©es plus exhaustives : le fichier brut sur data.gouv. Comme on peut le voir dans les mÃ©tadonnÃ©es, on sait quâ€™on a plus de 1000 Ã©coles dont on peut rÃ©cupÃ©rer des donnÃ©es, mais quâ€™on en a ici extrait seulement 20. Le champ next nous donne directement lâ€™URL Ã  utiliser pour rÃ©cupÃ©rer les 20 pages suivantes : câ€™est grÃ¢ce Ã  lui quâ€™on a une chance de rÃ©cupÃ©rer toutes nos donnÃ©es dâ€™intÃ©rÃªt.\n\n\nRÃ©ponse question 4\nurl_api_datagouv = \"https://tabular-api.data.gouv.fr/api/resources/b22f04bf-64a8-495d-b8bb-d84dbc4c7983/data/?Code_departement__exact=031\"\n\ncall_api_datagouv = requests.get(url_api_datagouv).json()\n\n\nLe problÃ¨me de la rÃ©cupÃ©ration de donnÃ©es via lâ€™API vient du fait que nous ne rÃ©cupÃ©rons quâ€™un petit Ã©chantillon Ã  chaque requÃªte. Pour y remÃ©dier, nous allons devoir faire plusieurs appels successifs. Dans le JSON obtenu ci-dessus, la partie intÃ©ressante pour automatiser la rÃ©cupÃ©ration de nos donnÃ©es est la clÃ© links. En bouclant sur celui-ci pour parcourir la liste des URL accessibles, on peut rÃ©cupÃ©rer des donnÃ©es.\n\n\nRÃ©ponse question 5\nimport requests\nimport pandas as pd\n\n# Initialize the initial API URL\nurl_api_datagouv = \"https://tabular-api.data.gouv.fr/api/resources/b22f04bf-64a8-495d-b8bb-d84dbc4c7983/data/?Code_departement__exact=031&page_size=50\"\n\n# Initialize an empty list to store all data entries\nall_data = []\n\n# Initialize the URL for pagination\ncurrent_url = url_api_datagouv\n\n# Loop until there is no next page\nwhile current_url:\n    try:\n        # Make a GET request to the current URL\n        response = requests.get(current_url)\n        response.raise_for_status()  # Raise an exception for HTTP errors\n\n        # Parse the JSON response\n        json_response = response.json()\n\n        # Extract data and append to the all_data list\n        page_data = json_response.get('data', [])\n        all_data.extend(page_data)\n        print(f\"Fetched {len(page_data)} records from {current_url}\")\n\n        # Get the next page URL\n        links = json_response.get('links', {})\n        current_url = links.get('next')  # This will be None if there's no next page\n\n    except requests.exceptions.RequestException as e:\n        print(f\"An error occurred: {e}\")\n        break\n\n\n\nschools_dep31 = pd.DataFrame(all_data)\nschools_dep31.head()\n\nOn peut fusionner ces nouvelles donnÃ©es avec nos donnÃ©es prÃ©cÃ©dentes pour enrichir celles-ci. Pour faire une production fiable, il faudrait faire attention aux Ã©coles qui ne sâ€™apparient pas, mais ce nâ€™est pas grave pour cette sÃ©rie dâ€™exercices.\n\nbpe_enriched = bpe.merge(\n  schools_dep31,\n  left_on = \"SIRET\",\n  right_on = \"SIREN_SIRET\"\n)\nbpe_enriched.head(2)\n\nCela nous donne des donnÃ©es enrichies de nouvelles caractÃ©ristiques sur les Ã©tablissements. Il y a des coordonnÃ©es gÃ©ographiques dans celles-ci, mais nous allons faire comme sâ€™il nâ€™y en avait pas pour rÃ©utiliser notre API de gÃ©olocalisation et ainsi avoir un alibi pour utiliser les requÃªtes POST."
  },
  {
    "objectID": "sessions/api.html#logique",
    "href": "sessions/api.html#logique",
    "title": "Atelier pour dÃ©couvrir la rÃ©cupÃ©ration de donnÃ©es via des API",
    "section": "4.1 Logique",
    "text": "4.1 Logique\nNous avons jusquâ€™Ã  prÃ©sent Ã©voquÃ© les requÃªtes GET. Nous allons maintenant prÃ©senter les requÃªtes POST qui permettent dâ€™interagir de maniÃ¨re plus complexe avec des serveurs de lâ€™API.\nPour dÃ©couvrir celles-ci, nous allons reprendre lâ€™API de gÃ©olocalisation prÃ©cÃ©dente mais utiliser un autre point dâ€™entrÃ©e qui nÃ©cessite une requÃªte POST.\nCes derniÃ¨res sont gÃ©nÃ©ralement utilisÃ©es quand il est nÃ©cessaire dâ€™envoyer des donnÃ©es particuliÃ¨res pour dÃ©clencher une action. Par exemple, dans le monde du web, si vous avez une authentification Ã  mettre en oeuvre, une requÃªte POST permettra dâ€™envoyer un token au serveur qui rÃ©pondra en acceptant votre authentification.\nDans notre cas, nous allons envoyer des donnÃ©es au serveur, ce dernier va les recevoir, les utiliser pour la gÃ©olocalisation puis nous envoyer une rÃ©ponse. Pour continuer sur la mÃ©taphore culinaire, câ€™est comme si vous donniez vous-mÃªmes Ã  la cuisine un tupperware pour rÃ©cupÃ©rer votre plat Ã  emporter."
  },
  {
    "objectID": "sessions/api.html#principe",
    "href": "sessions/api.html#principe",
    "title": "Atelier pour dÃ©couvrir la rÃ©cupÃ©ration de donnÃ©es via des API",
    "section": "4.2 Principe",
    "text": "4.2 Principe\nPrenons cette requÃªte proposÃ©e sur le site de documentation de lâ€™API de gÃ©olocalisation :\ncurl -X POST -F data=@path/to/file.csv -F columns=voie -F columns=ville -F citycode=ma_colonne_code_insee https://api-adresse.data.gouv.fr/search/csv/\nIci lâ€™objectif est dâ€™obtenir des gÃ©olocalisations pour les adresses textuelles prÃ©sentes dans un fichier .csv.\nComme nous avons pu lâ€™Ã©voquer prÃ©cÃ©demment, curl est un outil en ligne de commande qui permet de faire des requÃªtes API. Lâ€™option -X POST indique, de maniÃ¨re assez transparente, quâ€™on dÃ©sire faire une requÃªte POST.\nLes autres arguments sont passÃ©s par le biais des options -F. En lâ€™occurrence, on envoie un fichier et on ajoute des paramÃ¨tres pour aider le serveur Ã  aller chercher la donnÃ©e dedans. Lâ€™@ indique que file.csv doit Ãªtre lu sur le disque et envoyÃ© dans le corps de la requÃªte comme une donnÃ©e de formulaire."
  },
  {
    "objectID": "sessions/api.html#application-avec-python",
    "href": "sessions/api.html#application-avec-python",
    "title": "Atelier pour dÃ©couvrir la rÃ©cupÃ©ration de donnÃ©es via des API",
    "section": "4.3 Application avec Python",
    "text": "4.3 Application avec Python\nNous avions requests.get, il est donc logique que nous ayons requests.post. Cette fois, il faudra passer des paramÃ¨tres Ã  notre requÃªte sous la forme dâ€™un dictionnaire dont les clÃ©s sont le nom de lâ€™argument et les valeurs sont des objets Python.\nLe principal dÃ©fi, illustrÃ© dans le prochain exercice, est le passage de lâ€™argument data : il faudra renvoyer le fichier comme un objet Python par le biais de la fonction open.\n\n\n\n\n\n\nExercice 3 : une requÃªte POST pour gÃ©olocaliser en masse nos donnÃ©es\n\n\n\n\nEnregistrer au format CSV les colonnes adresse, DEPCOM et Nom_commune de la base dâ€™Ã©quipements fusionnÃ©e avec notre rÃ©pertoire prÃ©cÃ©dent (objet bpe_enriched). Il peut Ãªtre utile, avant lâ€™Ã©criture au format CSV, de remplacer les virgules dans la colonne adresse par des espaces.\nCrÃ©er lâ€™objet response avec requests.post et les bons arguments pour gÃ©ocoder votre CSV.\nTransformer votre output en objet Pandas avec la commande suivante :\n\nbpe_loc = pd.read_csv(io.StringIO(response.text))\n\n\n\n\nRÃ©ponse question 1\nimport pathlib\noutput_path = pathlib.Path(\"data/output\")\noutput_path.mkdir(parents=True, exist_ok=True)\ncsv_file = output_path / \"bpe_before_geoloc.csv\"\n\nbpe_enriched[\"adresse\"] = bpe_enriched[\"adresse\"].str.replace(\",\", \"\")\n\nbpe_enriched.loc[:, [\"adresse\", \"DEPCOM\", \"Nom_commune\"]].to_csv(csv_file)\n\n\n\n\nRÃ©ponse question 2 et 3\nimport io\n\nparams = {\n    \"columns\": [\"adresse\", \"Nom_commune\"],\n    \"citycode\": \"DEPCOM\",\n    \"result_columns\": [\"result_score\", \"latitude\", \"longitude\"],\n}\n\nresponse = requests.post(\n        \"https://api-adresse.data.gouv.fr/search/csv/\",\n        data=params,\n        files={\"data\": open(csv_file, \"rb\")},\n    )\n\n\nbpe_loc = pd.read_csv(io.StringIO(response.text))\nbpe_loc = bpe_loc.rename({\"Unnamed: 0\": \"index\"}, axis = \"columns\")\n\n\nLes gÃ©olocalisations obtenues prennent cette forme\nOn peut ensuite faire la jointure Ã  nos donnÃ©es initiales :\n\n\nJointure aux donnÃ©es initiales\nbpe_loc = bpe_loc.loc[:, [\"index\", \"result_score\", \"latitude\", \"longitude\"]]\nbpe_enriched_geocoded = (\n  bpe_enriched\n  .reset_index()\n  .merge(bpe_loc, on = \"index\", suffixes = [\"_annuaire\", \"_ban\"])\n  .drop(\"index\", axis = \"columns\")\n)\n\nbpe_enriched_geocoded.head(2)\n\n\n\n\nJointure aux donnÃ©es initiales\nbpe_enriched_geocoded = (\n    bpe_enriched_geocoded\n    .dropna(subset=[\"longitude_ban\",\"latitude_ban\"])\n)\n\nbpe_enriched_geocoded = gpd.GeoDataFrame(\n    bpe_enriched_geocoded,\n    geometry=gpd.points_from_xy(\n      bpe_enriched_geocoded['longitude_ban'],\n      bpe_enriched_geocoded['latitude_ban']\n      ),\n    crs=\"EPSG:4326\"\n)\n\n\nPour profiter de nos donnÃ©es enrichies, on peut faire une carte. Pour ajouter un peu de contexte Ã  celle-ci, on peut mettre un fond de carte des communes en arriÃ¨re plan. Celui-ci peut Ãªtre rÃ©cupÃ©rÃ© avec cartiflette :\n\n\nRÃ©cupÃ©ration du fond de carte (GEOJSON)\nfrom cartiflette import carti_download\nshp_communes = carti_download(\n  crs = 4326,\n  values = [\"31\"],\n  borders=\"COMMUNE\",\n  vectorfile_format=\"topojson\",\n  filter_by=\"DEPARTEMENT\",\n  source=\"EXPRESS-COG-CARTO-TERRITOIRE\",\n  year=2022\n)\nshp_communes.crs = 4326\n\n\n\n\nCode pour la carte interactive\nimport folium\nfrom folium.plugins import MarkerCluster\nimport geopandas as gpd\n\ndepartment_border = shp_communes.dissolve(by=\"INSEE_DEP\")\ncity_borders = shp_communes.copy()\n\nlongitude = bpe_enriched_geocoded.geometry.x.iloc[0]\nlatitude = bpe_enriched_geocoded.geometry.y.iloc[0]\nm = folium.Map(location=[latitude, longitude], zoom_start=10)\n\n# Add department border (black, bold)\nfolium.GeoJson(\n    data=department_border,\n    style_function=lambda x: {\n        \"fill\": False,\n        \"color\": \"black\",\n        \"weight\": 3  # Bold border\n    }\n).add_to(m)\n\n# Add city borders (blue, thin)\nfolium.GeoJson(\n    data=city_borders,\n    style_function=lambda x: {\n        \"fill\": False,\n        \"color\": \"blue\",\n        \"weight\": 1  # Thin border\n    }\n).add_to(m)\n\n# Initialize the MarkerCluster\nmarker_cluster = MarkerCluster().add_to(m)\n\ndef generate_popup(row):\n    # Initialiser le contenu avec le nom de l'Ã©cole\n    popup_content = f\"&lt;b&gt;Nom:&lt;/b&gt; {row['NOMRS']}&lt;br&gt;\"\n\n    # Ajouter \"Ecole Ã©lÃ©mentaire\" avec une icÃ´ne âœ…ï¸ ou âŒï¸ selon la valeur\n    ecole_element_status = \"âœ…ï¸\" if row.get('Ecole_elementaire', False) else \"âŒï¸\"\n    popup_content += f\"&lt;b&gt;Ecole Ã©lÃ©mentaire:&lt;/b&gt; {ecole_element_status}&lt;br&gt;\"\n\n    # Ajouter \"Nombre d'Ã©lÃ¨ves\" si disponible\n    if not pd.isnull(row.get('Nombre_d_eleves')):\n        popup_content += f\"&lt;b&gt;Nombre d'Ã©lÃ¨ves :&lt;/b&gt; {row['Nombre_d_eleves']}&lt;br&gt;\"\n\n    # Ajouter \"Voie gÃ©nÃ©rale\" si disponible\n    if not pd.isnull(row.get('Voie_generale')):\n        popup_content += f\"&lt;b&gt;Voie gÃ©nÃ©rale :&lt;/b&gt; {row['Voie_generale']}&lt;br&gt;\"\n\n    # Ajouter \"Voie technologique\" si disponible\n    if not pd.isnull(row.get('Voie_technologique')):\n        popup_content += f\"&lt;b&gt;Voie technologique :&lt;/b&gt; {row['Voie_technologique']}&lt;br&gt;\"\n\n    return popup_content\n\n\n# Add GeoDataFrame points to the MarkerCluster\nfor _, row in bpe_enriched_geocoded.iterrows():\n    # Create the popup content\n    popup_content = generate_popup(row)\n\n    popup = folium.Popup(popup_content, max_width=300)\n\n    # Add the marker to the cluster\n    folium.Marker(\n        location=[row.geometry.y, row.geometry.x],  # Extract latitude and longitude\n        popup=popup,\n        icon=folium.Icon(color=\"blue\", icon=\"info-sign\")\n    ).add_to(marker_cluster)\n\n# Display the map inline (optional for Jupyter Notebooks)\nm"
  },
  {
    "objectID": "sessions/api.html#bonnes-pratiques-pour-utiliser-un-token-dans-un-code-sans-le-rÃ©vÃ©ler",
    "href": "sessions/api.html#bonnes-pratiques-pour-utiliser-un-token-dans-un-code-sans-le-rÃ©vÃ©ler",
    "title": "Atelier pour dÃ©couvrir la rÃ©cupÃ©ration de donnÃ©es via des API",
    "section": "5.1 Bonnes pratiques pour utiliser un token dans un code sans le rÃ©vÃ©ler ğŸ‘®",
    "text": "5.1 Bonnes pratiques pour utiliser un token dans un code sans le rÃ©vÃ©ler ğŸ‘®\nLes tokens sont des informations personnelles qui ne doivent pas Ãªtre partagÃ©es. Ils nâ€™ont donc pas vocation Ã  apparaÃ®tre dans le code.\nComme ceci est Ã©voquÃ© Ã  plusieurs reprises dans le cours de mise en production en 3e annÃ©e de lâ€™ENSAE, il est important de sÃ©parer le code des Ã©lÃ©ments de configuration :\n\nLâ€™idÃ©e est de trouver une recette pour apporter les Ã©lÃ©ments de configuration avec le code mais sans mettre ceux-ci en clair dans le code. Lâ€™idÃ©e gÃ©nÃ©rale sera de stocker la valeur du token dans une variable mais ne jamais rÃ©vÃ©ler celle-ci dans le code. Comment faire dÃ¨s lors pour dÃ©clarer la valeur du jeton sans que celui-ci soit apparent dans le code ?\n\nPour un code amenÃ© Ã  fonctionner de maniÃ¨re interactive (par exemple par le biais dâ€™un notebook), il est possible de crÃ©er une boite de dialogue qui injectera la valeur renseignÃ©e dans une variable. Cela se fait par le biais du package getpass.\nPour le code qui tourne en non interactif, par exemple par le biais de la ligne de commande, lâ€™approche par variable dâ€™environnement est la plus fiable, Ã  condition de faire attention Ã  ne pas mettre le fichier de mot de passe dans Git . Pour cela, le plus simple est dâ€™utiliser dotenv si vous faites tourner votre code ou des secrets si votre code tourne par le biais de lâ€™intÃ©gration continue2.\n\n\n\n\n\n\n\nImportant\n\n\n\n\n\nIl ne faut jamais mettre de token dans Git. Sinon, vous courrez le risque dâ€™avoir votre identitÃ© usurpÃ©e : des robots scannent en continu Github Ã  la recherche de jetons pour ensuite lancer des dÃ©nis de service en se faisant passer pour vous.\nSi vous avez partagÃ© par erreur un jeton : pas de panique, cela peut arriver ! Lâ€™avantage des jetons est quâ€™ils sont rÃ©vocables : vous pouvez lâ€™invalider et en crÃ©er un nouveau pour continuer Ã  utiliser le service dÃ©sirÃ©. La bonne rÃ©action consiste Ã  rÃ©voquer le jeton le plus vite possible, une fois la fuite constatÃ©e. La meilleure parade pour Ã©viter ce type de fuite est dâ€™ajouter tout de suite le .env au .gitignore.\n\n\n\nLâ€™exercice 5 permettra de mettre en oeuvre ces deux mÃ©thodes. Ces mÃ©thodes nous serviront Ã  ajouter de maniÃ¨re confidentielle un payload Ã  des requÃªtes dâ€™authentification, câ€™est-Ã -dire des informations confidentielles identifiantes en complÃ©ment dâ€™une requÃªte."
  },
  {
    "objectID": "sessions/api.html#le-portail-des-api-de-linsee",
    "href": "sessions/api.html#le-portail-des-api-de-linsee",
    "title": "Atelier pour dÃ©couvrir la rÃ©cupÃ©ration de donnÃ©es via des API",
    "section": "5.2 Le portail des API de lâ€™Insee",
    "text": "5.2 Le portail des API de lâ€™Insee\nPour illustrer lâ€™utilisation des API authentifiÃ©es, nous proposons dâ€™explorer le portail des API de lâ€™Insee.\nNous allons nous concentrer sur lâ€™API Sirene mais, sur ce portail, il en existe dâ€™autres, notamment lâ€™API Melodi consacrÃ©e Ã  la rÃ©cupÃ©ration dâ€™un certain nombre de sources open data de lâ€™Insee. Lâ€™API Sirene est une version interrogeable des donnÃ©es Sirene open data.\n\n\n\n\n\n\nExercice 4 : API authentifiÃ©e par le biais du navigateur\n\n\n\n\nSe crÃ©er un compte sur le portail des API\nAller voir lâ€™espace Mes applications et en crÃ©er une nouvelle. Par simplicitÃ©, vous pouvez la nommer â€œAtelier SSPHubâ€.\nDans celle-ci, aller dans lâ€™onglet â€œClefs et jetonsâ€.CrÃ©er un jeton (vous pouvez laisser la durÃ©e de validitÃ© proposÃ©e).\nCliquer sur lâ€™onglet Souscriptions. Choisir lâ€™API Sirene.\nA droite, sÃ©lectionner lâ€™application crÃ©Ã©e prÃ©cÃ©demment. Si vous allez voir votre application, elle devrait maintenant pouvoir interagir avec lâ€™API Sirene.\n\nTestons maintenant lâ€™API Sirene grÃ¢ce au swagger (onglet Console de l'API) :\n\nPlus bas, dans la documentation interactive se rendre au point dâ€™entrÃ©e /siren/{siren} (mÃ©thode GET).\nRemplir le champ q avec le SIREN 500569405 (SIREN de DÃ©cathlon ğŸ˜‰)\nSi vous avez lâ€™erreur ci-dessous, comprenez-vous pourquoi ?\n\n\nChanger lâ€™application via le menu dÃ©roulant : maintenant que vous avez un token valide, soumettez Ã  nouveau la mÃªme requÃªte.\n\nVous devriez maintenant avoir cette sortie :\n\nsortie_sirene_decathlon"
  },
  {
    "objectID": "sessions/api.html#rÃ©cupÃ©ration-des-donnÃ©es-via-python",
    "href": "sessions/api.html#rÃ©cupÃ©ration-des-donnÃ©es-via-python",
    "title": "Atelier pour dÃ©couvrir la rÃ©cupÃ©ration de donnÃ©es via des API",
    "section": "5.3 RÃ©cupÃ©ration des donnÃ©es via Python ",
    "text": "5.3 RÃ©cupÃ©ration des donnÃ©es via Python \nPour la prochaine application, Ã  partir de la question 4, nous allons avoir besoin de crÃ©er une classe spÃ©ciale permettant Ã  requests de surcharger notre requÃªte dâ€™un jeton dâ€™authentification. Comme elle nâ€™est pas triviale Ã  crÃ©er sans connaissance prÃ©alable, la voici :\n\nclass BearerAuth(requests.auth.AuthBase):\n    def __init__(self, token):\n        self.token = token\n    def __call__(self, r):\n        r.headers[\"authorization\"] = \"Bearer \" + self.token\n        return r\n\n\n\n\n\n\n\nExercice 5 : les tokens avec Python\n\n\n\n\nCrÃ©er une variable token par le biais de getpass.\nUtiliser cette structure de code pour rÃ©cupÃ©rer la donnÃ©e voulue\n\nrequests.get(\n    url,\n    auth=BearerAuth(token)\n)\n\nRemplacer lâ€™utilisation de getpass par lâ€™approche variable dâ€™environnement grÃ¢ce Ã  dotenv.\n\n\n\n\n\nCorrection de lâ€™exercice\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nsiren=\"500569405\"\ntoken = os.getenv(\"TOKEN_API_INSEE\")\nif token is not None:\n    print(\"Token has been retrieved from env var\")\n\nr = requests.get(\n    f\"https://api.insee.fr/entreprises/sirene/V3.11/siren/{siren}\",\n    auth=BearerAuth(token)\n)\n\nsortie_sirene_decathlon = r.json()\nsortie_sirene_decathlon\n\n\n\nsortie_sirene_decathlon\n\n\n\n\n\n\nNous avons un dataframe avec de nombreux SIRET (bpe). On pourrait vouloir rÃ©cupÃ©rer des infos sur ceux-ci par le biais de lâ€™API. NÃ©anmoins les conditions dâ€™usage de celle-ci sont restrictives : pas plus de 30 appels par minute.\nOn ne peut donc faire une boucle sur notre dataframe sans contrÃ´ler le nombre dâ€™appels Ã  la minute. IdÃ©alement, nous ferions de lâ€™envoi par bash qui permet dâ€™envoyer plusieurs enregistrement Ã  la fois dans une seule requÃªte (comme nous avons fait pour les gÃ©olocalisations) mais ce nâ€™est pas possible : lâ€™API Sirene est une API pour de la consultation de donnÃ©es ponctuelles, pas du traitement statistique sur de gros volumes.\nLâ€™autre approche possible, que nous allons adopter, est de mettre un temps dâ€™attente entre chaque appel Ã  lâ€™API. Nous allons donc faire une boucle mais, entre chaque itÃ©ration, mettre un temps de repos de 2 secondes.\n\n\nFonction utile pour cet exercice\nsiret = \"21310001900024\"\n\ndef get_ape(siret: str = \"21310001900024\", token: str = \"\"):\n    info_siret = requests.get(\n        f\"https://api.insee.fr/entreprises/sirene/V3.11/siret/{siret}\",\n        auth=BearerAuth(token)\n    ).json()\n    ape = (info_siret\n        .get(\"etablissement\", {})\n        .get(\"uniteLegale\", {})\n        .get(\"activitePrincipaleUniteLegale\", {})\n    )\n    return ape\n\nget_ape(siret, token)\n\n\n\n\n\n\n\n\nExercice 6 : gÃ©nÃ©raliser des appels Ã  des API\n\n\n\nNous voulons rÃ©cupÃ©rer lâ€™activitÃ© pricnipal de nos Ã©tablissements (le code APE, qui devrait normalement Ãªtre 84.11Z).\nUtiliser le package time et sa fonction sleep pour marquer un temps dâ€™arrÃªt lorsquâ€™on itÃ©re sur les dix premiÃ¨res observations de notre dataframe pour rÃ©cupÃ©rer ce code.\n\n\n\n\nCorrection de lâ€™exercice\nimport time\n\nfirst_siret = []\n\nfor index, row in bpe.head(10).iterrows():\n    first_siret += [get_ape(row['SIRET'], token)]\n    time.sleep(2)"
  },
  {
    "objectID": "sessions/api.html#footnotes",
    "href": "sessions/api.html#footnotes",
    "title": "Atelier pour dÃ©couvrir la rÃ©cupÃ©ration de donnÃ©es via des API",
    "section": "Notes de bas de page",
    "text": "Notes de bas de page\n\n\nTechnique consistant Ã  singer le comportement dâ€™un navigateur web et de rÃ©cupÃ©rer de lâ€™information en moissonnant le HTML auquel accÃ¨de un site webâ†©ï¸\nCâ€™est par exemple lâ€™approche adoptÃ©e pour construire ces supports. Cela se fait de cette maniÃ¨re.â†©ï¸"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Masterclass du SSPHub",
    "section": "",
    "text": "Site web en construction"
  },
  {
    "objectID": "index.html#replays-des-sessions",
    "href": "index.html#replays-des-sessions",
    "title": "Masterclass du SSPHub",
    "section": "Replays des sessions",
    "text": "Replays des sessions\nA venir"
  }
]